{
  "language": "Solidity",
  "sources": {
    "contracts/ConformityState.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ncontract ConformityState {\n    enum State {\n        FUNCTIONING,\n        CORRECTIVE_MEASURE_NEEDED,\n        WAITING_REVIEW\n    }\n\n    State public constant CONFORMITY_STATE_FUNCTIONING = State.FUNCTIONING;\n    State public constant CONFORMITY_STATE_CORRECTIVE_MEASURE_NEEDED =\n        State.CORRECTIVE_MEASURE_NEEDED;\n    State public constant CONFORMITY_STATE_WAITING_REVIEW =\n        State.WAITING_REVIEW;\n\n    // Errors\n    error InvalidConformityState();\n\n    function assertValidConformityState(State state_) internal pure {\n        if (\n            state_ != State.FUNCTIONING &&\n            state_ != State.CORRECTIVE_MEASURE_NEEDED &&\n            state_ != State.WAITING_REVIEW\n        ) revert InvalidConformityState();\n    }\n}\n"
    },
    "contracts/custom/Clone.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts (simplified)\n// (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(\n                0x00,\n                or(\n                    shr(0xe8, shl(0x60, implementation)),\n                    0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000\n                )\n            )\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(\n                0x20,\n                or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3)\n            )\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n}\n"
    },
    "contracts/custom/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ncontract Ownable {\n    address public owner;\n\n    error UserNotOwner();\n    error ForbiddenTransferToZeroAddress();\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        _assertIsOwner();\n        _;\n    }\n\n    /** \n        @dev For use after cloning a contract, where initial memory is 0\n    */\n    function init(address sender_) public {\n        if (owner == address(0)) owner = sender_;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner == address(0)) revert ForbiddenTransferToZeroAddress();\n        owner = newOwner;\n    }\n\n    function _assertIsOwner() internal view {\n        if (!isOwner()) revert UserNotOwner();\n    }\n}\n"
    },
    "contracts/DAO/Executor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Based on Openzeppelin Contracts (last updated v4.9.0)\n\npragma solidity ^0.8.19;\n\nimport \"../custom/Ownable.sol\";\nimport \"../OpenZeppelin/utils/Address.sol\";\nimport \"./IExecutor.sol\";\n\ncontract Executor is IExecutor, Ownable {\n    // Type declarations\n    // State variables\n    bool private locked;\n\n    // Modifiers\n    modifier nonReentrant() {\n        if (locked) revert ReentrantCall();\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // Functions\n    //* constructor\n    //* receive function\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable override {}\n\n    //* fallback function (if exists)\n    //* external\n    //* public\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Only owner can execute, usually Governor Contract.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 salt\n    ) public payable override nonReentrant onlyOwner {\n        bytes32 id = hashOperation(target, value, payload, salt);\n\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Only owner can execute, usually Governor Contract.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 salt\n    ) public payable override nonReentrant onlyOwner {\n        if (\n            targets.length != values.length || targets.length != payloads.length\n        ) {\n            revert ExecutorInvalidOperationLength(\n                targets.length,\n                payloads.length,\n                values.length\n            );\n        }\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, salt);\n\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n    }\n\n    //* internal\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal {\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        Address.verifyCallResult(success, returndata);\n    }\n    //* private\n    //* asserts\n}\n"
    },
    "contracts/DAO/governance/extensions/GovernorCountingSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimple is Governor {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=for|agains\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        address account\n    ) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev See {IGovernor-getProposalVotesCount}.\n     */\n    function getProposalVotesCount(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        ) = proposalVotes(proposalId);\n        return againstVotes + forVotes + abstainVotes;\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    )\n        public\n        view\n        virtual\n        returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)\n    {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (\n            proposalVote.againstVotes,\n            proposalVote.forVotes,\n            proposalVote.abstainVotes\n        );\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     * In this module, the quorum is reached when there are enough FOR or AGAINST votes to meet the quorum\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return\n            quorum() <= proposalVote.forVotes ||\n            quorum() <= proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(\n        uint256 proposalId\n    ) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n    }\n}\n"
    },
    "contracts/DAO/governance/extensions/GovernorExecutor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Based on Openzeppelin Contracts (last updated v4.9.0)\n\npragma solidity ^0.8.19;\n\nimport \"../../IExecutor.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {Executer}.\n *\n * Using this model means the proposal will be operated by the {Executor} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {Executor}\n */\nabstract contract GovernorExecutor {\n    IExecutor private _executorContract;\n\n    // Type declarations\n    // State variables\n    // Events\n    /**\n     * @dev Emitted when the executor used for proposal execution is modified.\n     */\n    event ExecutorChange(address oldExecutor, address newExecutor);\n\n    // Errors\n    // Modifiers\n    // Functions\n    //* constructor\n\n    /**\n     * @dev Set the executor.\n     */\n    constructor(IExecutor executorAddress) {\n        _executorContract = executorAddress;\n    }\n\n    //* receive function\n    //* fallback function (if exists)\n    //* external\n    //* public\n    //* internal\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(_executorContract);\n    }\n\n    /**\n     * @dev Execute function that run the ready proposal through the executor.\n     */\n    function _execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual {\n        // execute\n        _executorContract.executeBatch{value: msg.value}(\n            targets,\n            values,\n            calldatas,\n            descriptionHash\n        );\n    }\n\n    /**\n     * @dev Update executor contract address.\n     */\n    function _updateExecutor(IExecutor newExecutor) internal {\n        emit ExecutorChange(address(_executorContract), address(newExecutor));\n        _executorContract = newExecutor;\n    }\n\n    //* private\n    //* asserts\n}\n"
    },
    "contracts/DAO/governance/extensions/GovernorSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettings is Governor {\n    uint256 private _votingPeriod;\n\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    constructor(uint256 initialVotingPeriod) {\n        _setVotingPeriod(initialVotingPeriod);\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(\n        uint256 newVotingPeriod\n    ) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n}\n"
    },
    "contracts/DAO/governance/extensions/GovernorVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../Governor.sol\";\nimport \"../../IUserRegistry.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotes is Governor {\n    IUserRegistry public userRegistry;\n\n    event UserRegistryUpdated(\n        IUserRegistry oldUserRegistry,\n        IUserRegistry newUserRegistry\n    );\n\n    constructor(IUserRegistry userRegistryAddress) {\n        userRegistry = userRegistryAddress;\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to timestamp..\n     */\n    function clock() public view virtual override returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    /**\n     * @dev Read the voting weight from the User Registry (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account\n    ) internal view virtual override returns (uint8) {\n        return userRegistry.getVotes(account);\n    }\n\n    /**\n     * @dev Update the user registry address.\n     *\n     * Emits a {UserRegistryUpdated} event.\n     */\n    function _setUserRegistry(\n        IUserRegistry newUserRegistryAddress\n    ) internal virtual onlyGovernance {\n        emit UserRegistryUpdated(userRegistry, newUserRegistryAddress);\n        userRegistry = newUserRegistryAddress;\n    }\n}\n"
    },
    "contracts/DAO/governance/Governor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Based on Openzeppelin Contracts (last updated v4.9.1)\n\npragma solidity ^0.8.19;\n\nimport \"../../OpenZeppelin/utils/math/SafeCast.sol\";\nimport \"../../OpenZeppelin/utils/Address.sol\";\nimport \"./extensions/GovernorExecutor.sol\";\nimport \"./IGovernor.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n *\n * Modified version of governance contracts from OpenZeppelin v4.9.1\n */\nabstract contract Governor is GovernorExecutor, IGovernor {\n    struct ProposalCore {\n        uint64 voteStart;\n        address proposer;\n        uint64 voteEnd;\n        bool executed;\n        bool canceled;\n    }\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private constant _ALL_PROPOSAL_STATES_BITMAP =\n        bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    string private _name;\n\n    /// @custom:oz-retyped-from mapping(uint256 => Governor.ProposalCore)\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        if (_executor() != msg.sender) {\n            revert GovernorOnlyExecutor(msg.sender);\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(\n        string memory name_,\n        IExecutor executor_\n    ) GovernorExecutor(executor_) {\n        _name = name_;\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encode(targets, values, calldatas, descriptionHash)\n                )\n            );\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline < currentTimepoint) {\n            return ProposalState.Expired;\n        }\n\n        if (_quorumReached(proposalId)) {\n            if (_voteSucceeded(proposalId)) {\n                return ProposalState.Succeeded;\n            } else {\n                return ProposalState.Defeated;\n            }\n        } else {\n            return ProposalState.Active;\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd;\n    }\n\n    /**\n     * @dev Returns the account that created a given proposal.\n     */\n    function proposalProposer(\n        uint256 proposalId\n    ) public view virtual override returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(\n        uint256 proposalId\n    ) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(\n        uint256 proposalId\n    ) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account`.\n     */\n    function _getVotes(address account) internal view virtual returns (uint8);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support` and voting `weight``.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight\n    ) internal virtual;\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        address proposer = msg.sender;\n\n        uint256 currentTimepoint = clock();\n\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            keccak256(bytes(description))\n        );\n\n        if (\n            targets.length != values.length ||\n            targets.length != calldatas.length ||\n            targets.length == 0\n        ) {\n            revert GovernorInvalidProposalLength(\n                targets.length,\n                calldatas.length,\n                values.length\n            );\n        }\n        if (_proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(\n                proposalId,\n                state(proposalId),\n                bytes32(0)\n            );\n        }\n\n        uint256 deadline = currentTimepoint + votingPeriod();\n\n        _proposals[proposalId] = ProposalCore({\n            proposer: proposer,\n            voteStart: SafeCast.toUint64(currentTimepoint),\n            voteEnd: SafeCast.toUint64(deadline),\n            executed: false,\n            canceled: false\n        });\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            currentTimepoint,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash\n        );\n\n        ProposalState currentState = state(proposalId);\n        if (currentState != ProposalState.Succeeded) {\n            revert GovernorUnexpectedProposalState(\n                proposalId,\n                currentState,\n                _encodeStateBitmap(ProposalState.Succeeded)\n            );\n        }\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _execute(targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash\n        );\n        uint256 voteCount = getProposalVotesCount(proposalId);\n        if (voteCount != 0) {\n            revert GovernorProposalAlreadyVotedOn(proposalId, voteCount);\n        }\n        if (msg.sender != proposalProposer(proposalId)) {\n            revert GovernorOnlyProposer(msg.sender);\n        }\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            descriptionHash\n        );\n\n        ProposalState currentState = state(proposalId);\n\n        bytes32 forbiddenStates = _encodeStateBitmap(ProposalState.Canceled) |\n            _encodeStateBitmap(ProposalState.Expired) |\n            _encodeStateBitmap(ProposalState.Executed);\n        if (forbiddenStates & _encodeStateBitmap(currentState) != 0) {\n            revert GovernorUnexpectedProposalState(\n                proposalId,\n                currentState,\n                _ALL_PROPOSAL_STATES_BITMAP ^ forbiddenStates\n            );\n        }\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(\n        address account\n    ) public view virtual override returns (uint8) {\n        return _getVotes(account);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint8 support\n    ) public virtual override returns (uint256) {\n        address voter = msg.sender;\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = msg.sender;\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        ProposalState currentState = state(proposalId);\n        if (currentState != ProposalState.Active) {\n            revert GovernorUnexpectedProposalState(\n                proposalId,\n                currentState,\n                _encodeStateBitmap(ProposalState.Active)\n            );\n        }\n\n        uint256 weight = _getVotes(account);\n        _countVote(proposalId, account, support, weight);\n\n        emit VoteCast(account, proposalId, support, weight, reason);\n\n        return weight;\n    }\n\n    /**\n     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `ProposalState` enum. For example:\n     *\n     * 0x000...10000\n     *   ^^^^^^------ ...\n     *         ^----- Succeeded\n     *          ^---- Defeated\n     *           ^--- Canceled\n     *            ^-- Active\n     *             ^- Pending\n     */\n    function _encodeStateBitmap(\n        ProposalState proposalState\n    ) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }\n}\n"
    },
    "contracts/DAO/governance/IGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.19;\n\nimport \"../../OpenZeppelin/interfaces/IERC6372.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernor is IERC6372 {\n    enum ProposalState {\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.\n     */\n    error GovernorInvalidProposalLength(\n        uint256 targets,\n        uint256 calldatas,\n        uint256 values\n    );\n\n    /**\n     * @dev The vote was already cast.\n     */\n    error GovernorAlreadyCastVote(address voter);\n\n    /**\n     * @dev The `account` is not a proposer.\n     */\n    error GovernorOnlyProposer(address account);\n\n    /**\n     * @dev The `account` is not the governance executor.\n     */\n    error GovernorOnlyExecutor(address account);\n\n    /**\n     * @dev The `proposalId` doesn't exist.\n     */\n    error GovernorNonexistentProposal(uint256 proposalId);\n\n    /**\n     * @dev The current state of a proposal is not the required for performing an operation.\n     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position\n     * counting from right to left.\n     *\n     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).\n     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).\n     *\n     * See {Governor-_encodeStateBitmap}.\n     */\n    error GovernorUnexpectedProposalState(\n        uint256 proposalId,\n        ProposalState current,\n        bytes32 expectedStates\n    );\n\n    /**\n     * @dev The voting period set is not a valid period.\n     */\n    error GovernorInvalidVotingPeriod(uint256 votingPeriod);\n\n    /**\n     * @dev Cannot cancel proposal because it has been voted on.\n     */\n    error GovernorProposalAlreadyVotedOn(uint256 proposalId, uint256 votes);\n\n    /**\n     * @dev The vote type used is not valid for the corresponding counting module.\n     */\n    error GovernorInvalidVoteType();\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance.\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev See {IERC6372}\n     */\n    function clock() public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev See EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(\n        uint256 proposalId\n    ) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(\n        uint256 proposalId\n    ) public view virtual returns (address);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     */\n    function quorum() public view virtual returns (uint8);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account) public view virtual returns (uint8);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(\n        uint256 proposalId,\n        address account\n    ) public view virtual returns (bool);\n\n    /**\n     * @notice module:voting\n     * @dev Total votes for proposal `proposalId`.\n     */\n    function getProposalVotesCount(\n        uint256 proposalId\n    ) public view virtual returns (uint256);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer but only before it has got any votes.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(\n        uint256 proposalId,\n        uint8 support\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n}\n"
    },
    "contracts/DAO/GovernorContract.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport \"./governance/extensions/GovernorCountingSimple.sol\";\nimport \"./governance/extensions/GovernorVotes.sol\";\nimport \"./governance/extensions/GovernorSettings.sol\";\nimport \"./governance/Governor.sol\";\nimport \"./IExecutor.sol\";\nimport \"./IUserRegistry.sol\";\n\ncontract GovernorContract is\n    Governor,\n    GovernorSettings,\n    GovernorCountingSimple,\n    GovernorVotes\n{\n    /** @dev Set low value during development, should be adjusted in production.\n     * Possible value 51 for majority.\n     */\n    uint8 constant QUORUM = 25;\n\n    constructor(\n        IExecutor executor_,\n        IUserRegistry userRegistry_,\n        uint256 votingPeriod_\n    )\n        Governor(\"TracerDAO\", executor_)\n        GovernorSettings(votingPeriod_)\n        GovernorVotes(userRegistry_)\n    {}\n\n    // The following functions are overrides required by Solidity.\n\n    function quorum() public pure override returns (uint8) {\n        return QUORUM;\n    }\n\n    function votingPeriod()\n        public\n        view\n        override(IGovernor, GovernorSettings)\n        returns (uint256)\n    {\n        return super.votingPeriod();\n    }\n}\n"
    },
    "contracts/DAO/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// Based on Openzeppelin Contracts (last updated v4.9.0)\n\npragma solidity ^0.8.19;\n\nabstract contract IExecutor {\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data\n    );\n\n    // Errors\n    /**\n     * @dev Prevent reentrant calls.\n     */\n    error ReentrantCall();\n\n    /**\n     * @dev Mismatch between the parameters length for an operation call.\n     */\n    error ExecutorInvalidOperationLength(\n        uint256 targets,\n        uint256 payloads,\n        uint256 values\n    );\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable virtual;\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Only owner can execute, usually Governor Contract.\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 salt\n    ) public payable virtual;\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Only owner can execute, usually Governor Contract.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 salt\n    ) public payable virtual;\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, salt));\n    }\n}\n"
    },
    "contracts/DAO/IUserRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport \"../ConformityState.sol\";\n\n/** @dev @TODO docs\n */\nabstract contract IUserRegistry {\n    uint8 constant MAX_VOTING_POWER = 49;\n\n    // Type declarations\n    struct Member {\n        address addr;\n        uint8 votingPower;\n        ConformityState.State state;\n        address managingContractAddress;\n        string name;\n        string infoURI;\n    }\n\n    struct Actor {\n        address addr;\n        ConformityState.State state;\n        string name;\n        string infoURI;\n        address[] participatingContracts;\n    }\n\n    // Errors\n    error UserAlreadyExists();\n    error MemberDoesNotExist();\n    error ActorDoesNotExist();\n    error TransactionNotFromOriginalActorAddress();\n    error UserCannotManageContract();\n    error InvalidVotingPower(uint8 votingPower);\n\n    function setTraceabilityContractFactoryAddress(\n        address addr_\n    ) external virtual;\n\n    function getMember(\n        address addr_\n    ) public view virtual returns (Member memory);\n\n    function getActor(address addr_) public view virtual returns (Actor memory);\n\n    function getActorName(\n        address addr_\n    ) public view virtual returns (string memory);\n\n    function getVotes(address member_) public view virtual returns (uint8);\n\n    function getManagingContractAddress(\n        address addr_\n    ) public view virtual returns (address);\n\n    function addMember(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_,\n        uint8 votingPower_\n    ) public virtual;\n\n    function updateMember(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public virtual;\n\n    function updateMember(\n        address addr_,\n        address managingContractAddress_\n    ) public virtual;\n\n    function updateMemberState(\n        address addr_,\n        ConformityState.State newState_\n    ) public virtual;\n\n    function addActor(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public virtual;\n\n    function updateActor(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public virtual;\n\n    function updateActorState(\n        address addr_,\n        ConformityState.State newState_\n    ) public virtual;\n\n    function addContractToActor(\n        address contract_,\n        address actor_\n    ) public virtual;\n\n    function checkAccess(\n        address contract_,\n        address addr_\n    ) public view virtual returns (bool);\n}\n"
    },
    "contracts/DAO/UserRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport \"../custom/Ownable.sol\";\nimport \"../ConformityState.sol\";\nimport \"./IUserRegistry.sol\";\n\ncontract UserRegistry is IUserRegistry, Ownable, ConformityState {\n    // State variables\n    uint256 public memberCount;\n    address private TraceabilityContractFactory;\n\n    mapping(address => Member) members;\n    mapping(address => Actor) actors;\n\n    // Modifiers\n    modifier onlyOwnerOrFactoryContract() {\n        if (!isOwner() && msg.sender != TraceabilityContractFactory)\n            revert UserNotOwner();\n        _;\n    }\n\n    modifier onlyOwnerOrFactoryOrManager(address contract_) {\n        if (\n            !isOwner() &&\n            msg.sender != TraceabilityContractFactory &&\n            members[msg.sender].managingContractAddress != contract_\n        ) revert UserNotOwner();\n        _;\n    }\n\n    // Functions\n\n    //* constructor\n\n    //* receive function\n\n    //* fallback function (if exists)\n\n    //* external\n    function setTraceabilityContractFactoryAddress(\n        address addr_\n    ) external override onlyOwner {\n        TraceabilityContractFactory = addr_;\n    }\n\n    //* public\n    function getMember(\n        address addr_\n    ) public view override returns (Member memory) {\n        return members[addr_];\n    }\n\n    function getActor(\n        address addr_\n    ) public view override returns (Actor memory) {\n        return actors[addr_];\n    }\n\n    function getActorName(\n        address addr_\n    ) public view override returns (string memory) {\n        return actors[addr_].name;\n    }\n\n    function getVotes(address member_) public view override returns (uint8) {\n        return members[member_].votingPower;\n    }\n\n    function getManagingContractAddress(\n        address addr_\n    ) public view override returns (address) {\n        return members[addr_].managingContractAddress;\n    }\n\n    function addMember(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_,\n        uint8 votingPower_\n    ) public override onlyOwner {\n        _assertMemberDoesNotExist(addr_);\n        _assertValidVotingPower(votingPower_);\n\n        memberCount++;\n\n        Member storage member = members[addr_];\n        member.addr = addr_;\n        member.name = name_;\n        member.infoURI = infoURI_;\n        member.votingPower = votingPower_;\n        member.state = ConformityState.CONFORMITY_STATE_FUNCTIONING;\n    }\n\n    function updateMember(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public override onlyOwner {\n        Member storage member = members[addr_];\n        _assertMemberExists(member);\n\n        member.name = name_;\n        member.infoURI = infoURI_;\n    }\n\n    function updateMember(\n        address addr_,\n        address managingContractAddress_\n    ) public override onlyOwnerOrFactoryContract {\n        Member storage member = members[addr_];\n        _assertMemberExists(member);\n\n        member.managingContractAddress = managingContractAddress_;\n    }\n\n    function updateMemberState(\n        address addr_,\n        ConformityState.State newState_\n    ) public override onlyOwner {\n        Member storage member = members[addr_];\n        ConformityState.assertValidConformityState(newState_);\n        _assertMemberExists(member);\n\n        member.state = newState_;\n    }\n\n    function addActor(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public override {\n        _assertActorDoesNotExist(addr_);\n\n        Actor storage actor = actors[addr_];\n        actor.addr = addr_;\n        actor.name = name_;\n        actor.infoURI = infoURI_;\n        actor.state = ConformityState.CONFORMITY_STATE_FUNCTIONING;\n    }\n\n    function updateActor(\n        address addr_,\n        string calldata name_,\n        string calldata infoURI_\n    ) public override {\n        Actor storage actor = actors[addr_];\n        _assertActorExists(actor);\n        _assertSenderIsActor(actor);\n\n        actor.name = name_;\n        actor.infoURI = infoURI_;\n    }\n\n    function updateActorState(\n        address addr_,\n        ConformityState.State newState_\n    ) public override onlyOwner {\n        Actor storage actor = actors[addr_];\n        ConformityState.assertValidConformityState(newState_);\n        _assertActorExists(actor);\n\n        actor.state = newState_;\n    }\n\n    function addContractToActor(\n        address contract_,\n        address actor_\n    ) public override onlyOwnerOrFactoryOrManager(contract_) {\n        actors[actor_].participatingContracts.push(contract_);\n    }\n\n    function checkAccess(\n        address contract_,\n        address addr_\n    ) public view override returns (bool) {\n        address[] memory contracts = actors[addr_].participatingContracts;\n        for (uint i = 0; i < contracts.length; i++) {\n            if (contracts[i] == contract_) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //* internal\n\n    //* private\n\n    //* asserts\n    function assertOpFromContractManager(\n        address sender_,\n        address contractAddress_\n    ) public view {\n        if (getManagingContractAddress(sender_) != contractAddress_)\n            revert(\"UserCannotManageContract();\");\n    }\n\n    function _assertMemberDoesNotExist(address addr_) internal view {\n        if (members[addr_].addr != address(0)) revert UserAlreadyExists();\n    }\n\n    function _assertActorDoesNotExist(address addr_) internal view {\n        if (actors[addr_].addr != address(0)) revert UserAlreadyExists();\n    }\n\n    function _assertMemberExists(Member storage member_) internal view {\n        if (member_.addr == address(0)) revert MemberDoesNotExist();\n    }\n\n    function _assertActorExists(Actor storage actor_) internal view {\n        if (actor_.addr == address(0)) revert ActorDoesNotExist();\n    }\n\n    function _assertSenderIsActor(Actor storage actor_) internal view {\n        if (actor_.addr != msg.sender)\n            revert TransactionNotFromOriginalActorAddress();\n    }\n\n    function _assertValidVotingPower(uint8 votingPower_) internal pure {\n        if (votingPower_ > MAX_VOTING_POWER)\n            revert InvalidVotingPower(votingPower_);\n    }\n}\n"
    },
    "contracts/OpenZeppelin/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.19;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint256);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "contracts/OpenZeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a\n     * `customRevert` function as a fallback when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with a `customRevert` function as a fallback revert reason when `target` reverts.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        function() internal view customRevert\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check if target is a contract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                if (target.code.length == 0) {\n                    revert AddressEmptyCode(target);\n                }\n            }\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or with a default revert error.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {\n        return verifyCallResult(success, returndata, defaultRevert);\n    }\n\n    /**\n     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a\n     * `customRevert` function as a fallback when `success` is `false`.\n     *\n     * Requirements:\n     *\n     * - `customRevert` must be a reverting function.\n     *\n     * _Available since v5.0._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        function() internal view customRevert\n    ) internal view returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, customRevert);\n        }\n    }\n\n    /**\n     * @dev Default reverting function when no `customRevert` is provided in a function call.\n     */\n    function defaultRevert() internal pure {\n        revert FailedInnerCall();\n    }\n\n    function _revert(bytes memory returndata, function() internal view customRevert) private view {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            customRevert();\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "contracts/OpenZeppelin/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "contracts/Traceability/Traceability.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport \"../custom/Ownable.sol\";\nimport \"../ConformityState.sol\";\nimport \"../DAO/IUserRegistry.sol\";\nimport \"../OpenZeppelin/interfaces/IERC6372.sol\";\nimport \"../OpenZeppelin/utils/math/SafeCast.sol\";\n\ncontract Traceability is Ownable, ConformityState, IERC6372 {\n    // Type declarations\n    struct Batch {\n        uint256 id;\n        address currentOwner;\n        ConformityState.State state;\n        string description;\n        Update[] updates;\n        Transaction[] transactions;\n    }\n\n    struct Update {\n        address owner;\n        uint48 ts; // as specified in EIP-6372\n        string documentURI;\n    }\n\n    struct Transaction {\n        address receiver;\n        Update info;\n        string[] additionalAttributesValues;\n    }\n\n    // State variables\n    mapping(uint256 => Batch) batches;\n\n    IUserRegistry private userRegistry;\n    address private manager;\n    string private contractDescription;\n\n    string[] private requiredTransactionAttributesKeys;\n\n    // Events\n    event NewBatch(address indexed owner, uint256 id);\n\n    // Errors\n    error UserIsNotCurrentBatchOwner();\n    error BatchDoesNotExist();\n    error UserNotAllowedToTransact();\n    error BatchFunctioningPause();\n    error InvalidAdditionalUpdateAttributes();\n\n    // Modifiers\n    modifier allowedActor() {\n        _assertAllowedActor(msg.sender);\n        _;\n    }\n\n    // Functions\n\n    //* constructor\n    //* receive function\n\n    //* fallback function (if exists)\n\n    /** \n        @dev mitigate metamask node errors\n    */\n    fallback() external {}\n\n    //* external\n\n    function init(\n        IUserRegistry userRegistry_,\n        address owner_,\n        address manager_,\n        string calldata contractDescription_,\n        string[] memory requiredTransactionAttributesKeys_\n    ) external {\n        if (address(userRegistry) == address(0)) {\n            // init can only be called once\n            userRegistry = IUserRegistry(userRegistry_);\n            manager = manager_;\n            contractDescription = contractDescription_;\n            requiredTransactionAttributesKeys = requiredTransactionAttributesKeys_;\n\n            super.init(owner_);\n        }\n    }\n\n    function changeConformityState(\n        uint256 batchId_,\n        ConformityState.State newState_\n    ) external onlyOwner {\n        ConformityState.assertValidConformityState(newState_);\n\n        batches[batchId_].state = newState_;\n    }\n\n    //* public\n\n    function getManager() public view returns (address) {\n        return manager;\n    }\n\n    function getContractDescription() public view returns (string memory) {\n        return contractDescription;\n    }\n\n    function getRequiredTransactionAttributesKeys()\n        public\n        view\n        returns (string[] memory)\n    {\n        return requiredTransactionAttributesKeys;\n    }\n\n    function getBatch(uint256 id_) public view returns (Batch memory) {\n        return batches[id_];\n    }\n\n    function newBatch(\n        string memory description_,\n        string memory documentURI_\n    ) public allowedActor returns (uint256) {\n        uint256 batchId = _generateId();\n        Batch storage batch = batches[batchId];\n        batch.id = batchId;\n        batch.description = description_;\n        batch.currentOwner = msg.sender;\n        batch.state = ConformityState.CONFORMITY_STATE_FUNCTIONING;\n\n        // handle create transaction\n        Transaction memory transaction = _newTransaction(\n            msg.sender,\n            documentURI_,\n            new string[](0)\n        );\n        batch.transactions.push(transaction);\n\n        emit NewBatch(msg.sender, batch.id);\n\n        return batchId;\n    }\n\n    function handleUpdate(\n        uint256 id_,\n        string memory documentURI_\n    ) public allowedActor {\n        Batch storage batch = batches[id_];\n        _assertValidUpdate(batch);\n        // Send BCEvent\n        // Record Update\n        Update memory update = _newUpdate(documentURI_);\n        batch.updates.push(update);\n    }\n\n    function handleTransaction(\n        uint256 id_,\n        address receiver_,\n        string memory documentURI_,\n        string[] memory additionalAttributesValues_\n    ) public allowedActor {\n        Batch storage batch = batches[id_];\n        _assertValidUpdate(batch);\n        _assertAllowedActor(receiver_);\n        _assertBatchFunctioning(batch);\n        _assertValidAdditionalAttributes(additionalAttributesValues_);\n\n        Transaction memory transaction = _newTransaction(\n            receiver_,\n            documentURI_,\n            additionalAttributesValues_\n        );\n        batch.transactions.push(transaction);\n\n        batch.currentOwner = receiver_;\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to timestamp.\n     */\n    function clock() public view virtual override returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    //* internal\n\n    function _newUpdate(\n        string memory documentURI_\n    ) internal view returns (Update memory) {\n        return Update(msg.sender, SafeCast.toUint48(clock()), documentURI_);\n    }\n\n    function _newTransaction(\n        address receiver_,\n        string memory documentURI_,\n        string[] memory additionalAttributesValues_\n    ) internal view returns (Transaction memory) {\n        return\n            Transaction(\n                receiver_,\n                _newUpdate(documentURI_),\n                additionalAttributesValues_\n            );\n    }\n\n    //* private\n\n    function _generateId() private view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encode(msg.sender, block.timestamp, block.prevrandao)\n                )\n            );\n    }\n\n    //* asserts\n\n    function _assertValidUpdate(Batch storage batch_) private view {\n        _assertBatchExists(batch_);\n        _assertCurrentOwner(batch_);\n    }\n\n    function _assertCurrentOwner(Batch storage batch_) private view {\n        if (batch_.currentOwner != msg.sender)\n            revert UserIsNotCurrentBatchOwner();\n    }\n\n    function _assertBatchExists(Batch storage batch_) private view {\n        if (batch_.id == 0) revert BatchDoesNotExist();\n    }\n\n    function _assertAllowedActor(address addr_) private view {\n        if (!userRegistry.checkAccess(address(this), addr_))\n            revert UserNotAllowedToTransact();\n    }\n\n    function _assertBatchFunctioning(Batch storage batch_) private view {\n        if (batch_.state != ConformityState.CONFORMITY_STATE_FUNCTIONING)\n            revert BatchFunctioningPause();\n    }\n\n    function _assertValidAdditionalAttributes(\n        string[] memory additionalAttributesValues_\n    ) private view {\n        if (\n            additionalAttributesValues_.length !=\n            requiredTransactionAttributesKeys.length\n        ) revert InvalidAdditionalUpdateAttributes();\n    }\n}\n"
    },
    "contracts/Traceability/TraceabilityContractFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport \"./Traceability.sol\";\nimport \"../custom/Clone.sol\";\nimport \"../custom/Ownable.sol\";\nimport \"../DAO/IUserRegistry.sol\";\n\ncontract TraceabilityContractFactory is Ownable {\n    address immutable defaultImplementation;\n    IUserRegistry private userRegistry;\n\n    constructor(address userRegistry_) {\n        userRegistry = IUserRegistry(userRegistry_);\n        defaultImplementation = address(new Traceability());\n    }\n\n    function create(\n        address supplychainManager_,\n        string calldata contractDescription_,\n        string[] memory requiredUpdateAttributesKeys_\n    ) external onlyOwner returns (address) {\n        address clone = Clones.clone(defaultImplementation);\n\n        // initialize the clone\n        Traceability(clone).init(\n            userRegistry,\n            msg.sender,\n            supplychainManager_,\n            contractDescription_,\n            requiredUpdateAttributesKeys_\n        );\n\n        userRegistry.updateMember(supplychainManager_, clone);\n\n        return clone;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}